# 多线程

## 线程概述

### 进程和线程

程序就是完成待定任务，用某种语言编写的一组指令的集合。即指一段静态的代码。

进程是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程（生命周期）。

- 进程作为资源分配的单位，系统在运行是为会给每个进程分配不同的内存区域

线程：进程可以进一步细化为线程，是一个程序内部的一条执行路径。

- 若一个进程同一时间并行执行多个线程，就是支持多线程的
- 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小
- 一个进程中的多个线程共享相同的内存单元/内存地址空间->它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程通信更简便、高效。**但是多个线程共享的系统资源可能带来安全的隐患。**

![单线程和多线程](https://tva1.sinaimg.cn/large/007S8ZIlly1gfosq3jfumj30c506f0t0.jpg)



JVM（Java Virtual Machine）

虚拟机栈和程序计数器是一个线程一份

方法区和堆是一个进程一份，多个线程要共享方法区和堆





**并行和并发**

并行：多个CPU同时执行多个任务，多个人做不同的事。

并发：一个CPU执行多个任务，运行速度非常快，让我们感觉是在同时执行多个任务。举例，秒杀，多个人做同一件事



### 多线程的优势

多线程的优点？

![多线程的优点](https://tva1.sinaimg.cn/large/007S8ZIlly1gfostsjw7vj30nh0aamyd.jpg)



什么时候需要使用多线程？

![image-20200612000954516](https://tva1.sinaimg.cn/large/007S8ZIlly1gfosvdf4exj30ln08wwfz.jpg)

主线程执行的同时可以增加一个垃圾回收的线程。





## 线程的创建和启动



### 继承Thread类创建线程类

```java
// 单线程示例
public class Sample {
    public void method() {
        System.out.println("正在执行方法");
    }
    
    public static void main(String[] args) {
        new Sample().method();
    }
    
}
```



```java
public class FirstThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() 
                                   + ":" + i);
            }
        }
    }
    
    public static void main(String[] args) {
        // 子线程
        FirstThread t1 = new FirstThread();
        t1.start();
        
        // 主线程
        for (int i = 0; i <100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() 
                                   + ":" + i);
            }
        }
    }
}
```



问题1：不能通过 t.run() 调用多线程，t.start() 和 t.run() 的区别？





问题2：再启动一个线程，遍历100以内的偶数





```java
// 练习：创建两个线程，一个遍历100以内的偶数，一个遍历100以内的奇数（两个线程做的事情是不同的，就是run方法不同）
public class ThreadDemo {
    public static void main(String[] args) {
        Thread1 t1 = new Thread1();
        Thread2 t2 = new Thread2();
        t1.start();
        t2.start();
        
        // 创建Thread类的匿名子类的方式
        new Thread() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    if (i % 2 == 0) {
                        System.out.println(Thread.currentThread().getName() + ":" + i);
                    }
                }
    		}
        }.start();
    }
}

public class Thread1 {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

public class Thread2 {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}
```



窗口卖票问题，线程不安全

```java
// 买票问题，3个窗口同时卖票
class Window extends Thread {
	
    // 这种方式必须加上一个static，静态变量是共享的
    private static int ticket = 100;

    @Override
    public void run() {
        while (true) {
            if (ticket > 0) {
                System.out.println(getName() + "：卖票，票号为："
                        + ticket);
                ticket--;
            } else {
                break;
            }
        }
    }

    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

但是会出现一些问题，线程安全问题，待解决。

```
窗口1：卖票，票号为：100
窗口3：卖票，票号为：100
窗口2：卖票，票号为：100
窗口3：卖票，票号为：98
窗口1：卖票，票号为：99
窗口3：卖票，票号为：96
...
```



### 实现Runnable接口创建线程类

```
1. 创建一个实现了Runnable接口的类
2. 实现类实现Runnable中的抽象方法，run()方法
3. 创建实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中,创建Thread类的对象
5. 通过Thread类的对象调用start()方法
```



```java
public class SecondThread implements Runnable {
    @Override
    public void run() {
        
    }
    
    
    public static void main(String[] args) {
        
    }
}
```





比较继承Thread类和实现Runnable接口两种方式

开发中，优先选择实现Runnale接口的方式

原因：

1. 实现的方式没有类的单继承性的局限性
2. 实现的方式更适合来处理多个线程有共享数据的情况

联系：public class Thread implements Runnable

相同点：两种方式都需要重写run()方法，将线程要执行的逻辑声明在run()方法中。



学习到day19多线程





### 使用Callable和Future创建线程类















## 线程的生命周期

### 新建和就绪的状态







### 运行和阻塞状态







### 线程死亡







## 控制线程

### Thread类的常用方法

| 方法               | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| start()            | 启动当前线程，调用当前线程的run()方法                        |
| run()              | 通常需要重写Thread类中的此方法，将创建线程需要执行的操作声明在此方法中 |
| currentThread()    | **静态方法**，返回当前执行代码的线程                         |
| setName()          | 设置当前线程的名称                                           |
| getName()          | 获取当前线程的名称                                           |
| yield()            | 释放当前cpu的执行线程权                                      |
| join()             | 在线程a中调用线程b，此时线程a进入阻塞状态，直到线程b执行结束，线程a结束阻塞状态 |
| stop()             | ~~已过时。当执行此方法时，强制结束当前线程。~~               |
| sleep(long millis) | **静态方法**，让当前线程睡眠指定时间（毫秒），线程阻塞。     |
| isAlive()          | 判断当前线程是否存活                                         |



### join线程





### 后台线程





### 线程睡眠







### 改变线程的优先级

设置优先级

- MAX_PRIORITY：10
- MIN_PRIORITY：1
- NORM_PRIORITY：5——默认优先级

```java
public class ThreadTest {
    public static void main(String[] args) {
        // 子线程
        
        
        
        // 主线程
        currentThread().setName("main线程");
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + )
        }
    }
}

public MyThread extends Thread {
    @Override
    public void run() {
        
    }
}
```











## 线程的同步（重点）

解决的是线程的安全问题，一共有三种方式。

两种：同步代码块和同步方法

还有一种是使用log的方式。

### 同步安全问题

### 同步代码块

### 同步方法

### 释放同步监视器

### 同步锁

### 死锁





## 线程的通信



### 传统的线程通信







### 使用Condition控制线程通信









### 使用阻塞队列（BlockingQueue）控制线程通信











## 线程池

### C3P0







### Druid











## 线程相关的类

### ThreadLocal类







### 包装线程不安全的集合





### 线程安全的集合







